sign-min := avm &
  [ STEM list ].

basic-sign := sign-min &
  [ KEY-ARG bool ].

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list ].

phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
       [ LOCAL.CONT.HOOK #hook],
    C-CONT mrs-min & [ HOOK #hook] ].

word-or-lexrule-min := sign-min.

word-or-lexrule := word-or-lexrule-min & sign &
  [ ALTS alts-min,
    ARG-ST list ].

alts-min := avm.
alts := alts-min &
  [ PASSIVE bool ].
no-alts := alts-min.

word := word-or-lexrule.

lex-item := word-or-lexrule.

phrase := phrase-or-lexrule.

non-affix-bearing := word-or-lexrule &
  [ SYNSEM.LKEYS.KEYREL.WLINK cons ].

rule := sign &
  [ RULE-NAME string ].

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ].

synsem-min := avm &
  [ OPT bool,
    LOCAL mod-local ].

lex-or-phrase-synsem := synsem-min &
  [ LIGHT luk ].

synsem := synsem-min &
  [ L-PERIPH luk,
    R-PERIPH luk ].

expressed-synsem := synsem.

canonical-synsem := expressed-synsem &
  [ MODIFIED xmod ].

lex-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LIGHT +,
    LKEYS lexkeys ].

phr-synsem-min := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min ].

phr-synsem := phr-synsem-min &
  [ LIGHT - ].

non-canonical := synsem &
  [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ].

expressed-non-canonical := non-canonical & expressed-synsem.

gap := expressed-non-canonical &
  [ LOCAL #local ].

unexpressed := synsem-min.

unexpressed-reg := unexpressed & non-canonical.


anti-synsem := unexpressed.

mod-local := avm.

local-min := mod-local &
  [ CAT cat-min,
    CONT mrs-min,
    AGR individual ].

local := local-min &
  [ CTXT ctxt-min ].

scopal-mod := local.
intersective-mod := local.

cat-min := avm.

cat := cat-min &
  [ HEAD head-min,
    VAL valence-min,
    MC luk,
    HC-LIGHT luk,
    POSTHEAD bool ].

cat-sat := cat &
 [ VAL [ SPR olist,
         SPEC olist,
         COMPS olist,
         SUBJ olist ],
  HEAD.MOD olist ].

head-min := avm.

head := head-min &
  [ MOD list,
    PRD bool,
    KEYS keys_min ].


conj := +mo & +do & +co & +po & +ro & +jo & +vo & +no.
num := +mo & +dm & +cm & +pm & +rm & +jm & +vm & +nm.
det := +do & +dm & +cd & +pd & +rd & +jd & +vd & +nd.
comp := +co & +cm & +cd & +pc & +rc & +jc & +vc & +nc.
adp := +po & +pm & +pd & +pc & +rp & +jp & +vp & +np.
adv := +ro & +rm & +rd & +rc & +rp & +jr & +vr & +nr.
adj := +jo & +jm & +jd & +jc & +jp & +jr & +vj & +nj.
verb := +vo & +vm & +vd & +vc & +vp & +vr & +vj & +nv.
noun := +no & +nm & +nd & +nc & +np & +nr & +nj & +nv.

valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    SPEC list,
    --KEYCOMP avm ].

keys_min := avm.
keys := keys_min &
  [ KEY predsort,
    ALTKEY predsort ].

semsort := sort.

mrs-min := avm.

mrs := mrs-min &
  [ HOOK hook,
    RELS diff-list,
    HCONS diff-list ].

hook := avm &
  [ GTOP handle,
    LTOP handle,
    INDEX individual,
    XARG individual,
    CLAUSE-KEY event ].

psoa := mrs &
  [ HOOK.INDEX event ].

nom-obj := mrs &
  [ HOOK.INDEX index ].

lexkeys := avm &
  [ KEYREL relation,
    ALTKEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort ].

ctxt-min := avm.

ctxt := ctxt-min &
  [ ACTIVATED bool,
    PRESUP diff-list ].


qeq := avm &
  [ HARG handle,
    LARG handle ].


semarg := avm &
  [ INSTLOC string ].

handle := semarg.
individual := semarg &
  [ SORT semsort ].

index := individual &
     [ SPECI bool ].

event-or-ref-index := individual.

expl-ind := index.

ref-ind := index & event-or-ref-index &
    [ PNG png ].

png := avm.

tense := sort.
aspect := sort.
mood := sort.

tam := avm &
  [ TENSE tense,
    ASPECT aspect,
    MOOD mood ].

iforce := avm.
prop-or-ques := iforce.
prop := prop-or-ques.
ques := prop-or-ques.
comm := iforce.

event := event-or-ref-index &
  [ E tam,
    SF iforce ].

relation := avm &
  [ LBL handle,
    WLINK list,
    PRED predsort ].

arg0-relation := relation &
  [ ARG0 individual ].

arg1-relation := arg0-relation &
  [ ARG1 semarg ].

arg12-relation := arg1-relation &
  [ ARG2 semarg ].

event-relation := arg0-relation &
  [ ARG0 event ].

arg1-ev-relation := arg1-relation & event-relation.
arg12-ev-relation := arg1-ev-relation & arg12-relation.

noun-relation := arg0-relation &
  [ ARG0 ref-ind ].

noun-arg1-relation := noun-relation & arg1-relation.

named-relation := noun-relation &
  [ PRED named_rel,
    CARG string ].

quant-relation := arg0-relation &
  [ ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

norm_rel := predsort.
named_rel := norm_rel.

luk := sort.

na-or-+ := luk.
na-or-- := luk.
+-or-- := luk.

na := na-or-+ & na-or--.
bool := luk.
+ := bool & na-or-+ & +-or--.
- := bool & na-or-- & +-or--.

xmod := sort &
  [ PERIPH luk ].
notmod-or-rmod := xmod.
notmod-or-lmod := xmod.
notmod := notmod-or-rmod & notmod-or-lmod.

hasmod := xmod.
lmod := hasmod & notmod-or-lmod.
rmod := hasmod & notmod-or-rmod.

sort := *top*.
predsort := sort.
atom := predsort.
no-pred := predsort.
avm := *top*.
list := avm.

cons := list &
  [ FIRST *top*,
    REST list ].

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
  [ LIST list,
    LAST list ].

0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].

1-dlist := 0-1-dlist &
  [ LIST 1-list &
     [ REST #rest ],
    LAST #rest ].


dl-append := avm & [APPARG1 [LIST #first,
                             LAST #between],
                    APPARG2 [LIST #between,
                             LAST #last],
                    RESULT  [LIST #first,
                             LAST #last]].

integer := atom.

string := atom.

olist := list.

ocons := olist & cons &
  [ FIRST unexpressed & [ OPT + ],
    REST  olist ].

onull := olist & null.


headed-phrase := phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr ],
    HEAD-DTR.SYNSEM.LOCAL local &
         [ CAT.HEAD #head,
           AGR #agr ] ].

non-headed-phrase := phrase.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

head-nexus-rel-phrase := headed-phrase.

head-nexus-que-phrase := headed-phrase.

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

head-valence-phrase := head-nexus-phrase.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM [ L-PERIPH #lperiph,
         R-PERIPH #rperiph,
         LOCAL [ CONT [ RELS [ LIST #first,
                   LAST #last ],
                HCONS [ LIST #scfirst,
                    LAST #sclast ] ] ] ],
    C-CONT [ RELS [ LIST #middle,
            LAST #last ],
         HCONS [ LIST #scmiddle,
             LAST #sclast ] ],
    ARGS < sign & [ STEM #stem,
            SYNSEM [ L-PERIPH #lperiph,
                 R-PERIPH #rperiph,
                 LOCAL local &
                  [ CONT [ RELS [ LIST #first,
                          LAST #middle ],
                       HCONS [ LIST #scfirst,
                           LAST #scmiddle ] ] ] ] ] > ].

unary-phrase := basic-unary-phrase.

basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
            HCONS [ LIST #scfirst,
                    LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle2,
                    LAST #last ],
         HCONS [ LIST #scmiddle2,
                 LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #first,
                                 LAST #middle1 ],
                      HCONS [ LIST #scfirst,
                              LAST #scmiddle1 ] ] ] ],
       sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle1,
                                 LAST #middle2 ],
                      HCONS [ LIST #scmiddle1,
                              LAST #scmiddle2 ] ] ] ] > ].

binary-phrase := basic-binary-phrase.

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

basic-ternary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
            HCONS [ LIST #scfirst,
                    LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle3,
                    LAST #last ],
         HCONS [ LIST #scmiddle3,
                 LAST #sclast ] ],
    ARGS <
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #first,
                                 LAST #middle1 ],
                      HCONS [ LIST #scfirst,
                              LAST #scmiddle1 ] ] ] ],
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle1,
                                 LAST #middle2 ],
                      HCONS [ LIST #scmiddle1,
                              LAST #scmiddle2 ] ] ] ],
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle2,
                                 LAST #middle3 ],
                      HCONS [ LIST #scmiddle2,
                              LAST #scmiddle3 ] ] ] ]> ].

ternary-phrase := basic-ternary-phrase.

ternary-headed-phrase := headed-phrase & ternary-phrase.

ternary-head-middle-phrase := ternary-headed-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR #head &
        [ SYNSEM.LOCAL.CAT.VAL #val ],
    ARGS.REST.FIRST #head ].


binary-rule-left-to-right := basic-binary-phrase &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary-rule-right-to-left := basic-binary-phrase &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

clause := phrasal.

basic-non-rel-clause := clause & head-compositional &
  [ HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #index,
                                        CLAUSE-KEY #index ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

declarative-clause := basic-non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques ].

imperative-clause := basic-non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm ].


basic-head-subj-phrase := head-valence-phrase & head-compositional &
              basic-binary-headed-phrase &
  [ SYNSEM phr-synsem &
           [ LOCAL.CAT [ HC-LIGHT -,
                         VAL [ SUBJ < >,
                               COMPS #comps,
                               SPR #spr ] ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #synsem >,
                                    COMPS #comps,
                                    SPR #spr ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
           [ LOCAL [ CAT [ VAL [ SUBJ olist,
                                 COMPS olist,
                                 SPR olist ] ] ] ],
    C-CONT [ RELS <! !>, HCONS <! !> ] ].

decl-head-subj-phrase := basic-head-subj-phrase & declarative-clause.

basic-bare-np-phrase := head-only & head-valence-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           SUBJ < >,
                           COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL [ SPR < unexpressed &
                                              [ LOCAL.CAT.HEAD +nd,
                                                OPT + ] >,
                                        SUBJ < >,
                                        COMPS < > ] ],
                            CONT.HOOK [ INDEX #index,
                                        LTOP #larg ] ],
    C-CONT [ RELS <! quant-relation &
                     [ ARG0 #index,
                       RSTR #harg ] !>,
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #larg ] !>,
             HOOK [ INDEX #index ] ] ].


norm-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop ],
                          RELS.LIST.FIRST #keyrel ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

norm-hook-lex-item := norm-ltop-lex-item &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX #index,
             LKEYS.KEYREL.ARG0 #index ] ].

no-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST.FIRST #keyrel,
                          HOOK.INDEX #index ],
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].


raise-index-mod-lex-item := norm-ltop-lex-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                   CONT.HOOK.INDEX #index ] ].

single-rel-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

no-hcons-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.HCONS <! !> ].

norm-sem-lex-item := norm-hook-lex-item & single-rel-lex-item.

basic-one-arg := lex-item &
  [ ARG-ST < synsem-min > ].

basic-two-arg := lex-item &
  [ ARG-ST < synsem-min, synsem-min > ].

basic-two-arg-no-hcons := basic-two-arg & no-hcons-lex-item.

transitive-lex-item := basic-two-arg-no-hcons &
   [ ARG-ST < [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind1] ] ],
              [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind2 ] ] ]>,
     SYNSEM [ LKEYS.KEYREL [ ARG1 #ind1,
                             ARG2 #ind2 ],
              LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] ].

basic-verb-lex-super := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD verb ].

basic-verb-lex := basic-verb-lex-super & norm-sem-lex-item &
  [ SYNSEM.LKEYS.KEYREL event-relation ].

basic-noun-lex := norm-sem-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD noun,
             LKEYS.KEYREL noun-relation ]].

noun-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD noun,
                         VAL.SUBJ < > ],
             LKEYS.KEYREL noun-relation ] ].

intransitive-verb-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ ARG-ST < [ LOCAL [ CAT cat-sat,
                       CONT.HOOK.INDEX ref-ind & #ind ] ] >,
    SYNSEM.LKEYS.KEYREL event-relation & [ ARG1 #ind ] ].
    
subj-head-phrase := basic-head-subj-phrase & head-final.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].
