sign-min := avm &
  [ STEM list ].

basic-sign := sign-min.

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list ].

sort := *top*.
predsort := sort.
atom := predsort.
no-pred := predsort.
norm_rel := predsort.
named_rel := norm_rel.

avm := *top*.

list := avm.

cons := list &
  [ FIRST *top*,
    REST list ].

olist := list.
ocons := olist & cons &
  [ FIRST unexpressed,
    REST  olist ].
onull := olist & null.

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
  [ LIST list,
    LAST list ].
0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].
1-dlist := 0-1-dlist &
  [ LIST 1-list &
     [ REST #rest ],
    LAST #rest ].

integer := atom.
string := atom.

phrase-or-lexrule := sign &
  [ SYNSEM expressed-synsem &
       [ LOCAL.CONT.HOOK #hook],
    C-CONT mrs & [ HOOK #hook] ].

word-or-lexrule-min := sign-min.

word-or-lexrule := word-or-lexrule-min & sign &
  [ ALTS alts-min,
    ARG-ST list ].

alts-min := avm.
alts := alts-min.
no-alts := alts-min.

lex-item := word-or-lexrule.

phrase := phrase-or-lexrule.

rule := sign &
  [ RULE-NAME string ].

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ].

synsem := avm &
  [ LOCAL mod-local ].

lex-or-phrase-synsem := synsem.

expressed-synsem := synsem.

lex-synsem := expressed-synsem & lex-or-phrase-synsem &
  [ LOCAL local,
    LKEYS lexkeys ].

phr-synsem := expressed-synsem & lex-or-phrase-synsem &
  [ LOCAL local ].

non-canonical := synsem &
  [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ].

expressed-non-canonical := non-canonical & expressed-synsem.

unexpressed := synsem.

unexpressed-reg := unexpressed & non-canonical.

mod-local := avm.

local := mod-local &
  [ CAT cat,
    CONT mrs,
    AGR individual,
    CTXT ctxt ].

cat := avm &
  [ HEAD head-min,
    VAL valence-min ].

cat-sat := cat &
 [ VAL [ SPR olist,
         SPEC olist,
         COMPS olist,
         SUBJ olist ],
  HEAD.MOD olist ].

head-min := avm.

head := head-min &
  [ MOD list,
    KEYS keys_min ].

verb-or-noun := head.
verb := verb-or-noun.
noun := verb-or-noun.

valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    SPEC list ].

keys_min := avm.
keys := keys_min &
  [ KEY predsort,
    ALTKEY predsort ].

mrs := avm &
  [ HOOK hook,
    RELS diff-list,
    HCONS diff-list ].

hook := avm &
  [ GTOP handle,
    LTOP handle,
    INDEX individual,
    XARG individual,
    CLAUSE-KEY event ].

psoa := mrs &
  [ HOOK.INDEX event ].

nom-obj := mrs &
  [ HOOK.INDEX index ].

lexkeys := avm &
  [ KEYREL relation,
    ALTKEYREL relation ].

ctxt := avm &
  [ PRESUP diff-list ].

qeq := avm &
  [ HARG handle,
    LARG handle ].

semarg := avm &
  [ INSTLOC string ].

handle := semarg.
individual := semarg.

index := individual.

event-or-ref-index := individual.

expl-ind := index.

ref-ind := index & event-or-ref-index.
    
event := event-or-ref-index.

relation := avm &
  [ LBL handle,
    WLINK list,
    PRED predsort ].

arg0-relation := relation &
  [ ARG0 individual ].

arg1-relation := arg0-relation &
  [ ARG1 semarg ].

arg12-relation := arg1-relation &
  [ ARG2 semarg ].

event-relation := arg0-relation &
  [ ARG0 event ].

arg1-ev-relation := arg1-relation & event-relation.
arg12-ev-relation := arg1-ev-relation & arg12-relation.

noun-relation := arg0-relation &
  [ ARG0 ref-ind ].

noun-arg1-relation := noun-relation & arg1-relation.

named-relation := noun-relation &
  [ PRED named_rel,
    CARG string ].

quant-relation := arg0-relation &
  [ ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

headed-phrase := phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr ],
    HEAD-DTR.SYNSEM.LOCAL local &
         [ CAT.HEAD #head,
           AGR #agr ] ].

non-headed-phrase := phrase.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

head-nexus-rel-phrase := headed-phrase.

head-nexus-que-phrase := headed-phrase.

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.

head-valence-phrase := head-nexus-phrase.

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM [ LOCAL [ CONT [ RELS [ LIST #first,
                                   LAST #last ],
                HCONS [ LIST #scfirst,
                        LAST #sclast ] ] ] ],
    C-CONT [ RELS [ LIST #middle,
                    LAST #last ],
         HCONS [ LIST #scmiddle,
                 LAST #sclast ] ],
    ARGS < [ STEM #stem,
             SYNSEM [ LOCAL local &
                        [ CONT [ RELS [ LIST #first,
                                        LAST #middle ],
                       HCONS [ LIST #scfirst,
                               LAST #scmiddle ] ] ] ] ] > ].

unary-phrase := basic-unary-phrase.

basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
            HCONS [ LIST #scfirst,
                    LAST #sclast ] ],
    C-CONT [ RELS [ LIST #middle2,
                    LAST #last ],
         HCONS [ LIST #scmiddle2,
                 LAST #sclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #first,
                                 LAST #middle1 ],
                      HCONS [ LIST #scfirst,
                              LAST #scmiddle1 ] ] ] ],
       sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle1,
                                 LAST #middle2 ],
                      HCONS [ LIST #scmiddle1,
                              LAST #scmiddle2 ] ] ] ] > ].

binary-phrase := basic-binary-phrase.

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].

clause := phrasal.

basic-non-rel-clause := clause & head-compositional &
  [ HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #index,
                                        CLAUSE-KEY #index ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

basic-head-subj-phrase := head-valence-phrase & head-compositional &
              basic-binary-headed-phrase &
  [ SYNSEM phr-synsem &
           [ LOCAL.CAT [ VAL [ SUBJ < >,
                               COMPS #comps,
                               SPR #spr ] ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #synsem >,
                                    COMPS #comps,
                                    SPR #spr ],
    NON-HEAD-DTR.SYNSEM #synsem & expressed-synsem &
           [ LOCAL [ CAT [ VAL [ SUBJ olist,
                                 COMPS olist,
                                 SPR olist ] ] ] ],
    C-CONT [ RELS <! !>, HCONS <! !> ] ].

basic-bare-np-phrase := head-only & head-valence-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           SUBJ < >,
                           COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL [ SPR < unexpressed &
                                              [ LOCAL.CAT.HEAD noun ] >,
                                        SUBJ < >,
                                        COMPS < > ] ],
                            CONT.HOOK [ INDEX #index,
                                        LTOP #larg ] ],
    C-CONT [ RELS <! quant-relation &
                     [ ARG0 #index,
                       RSTR #harg ] !>,
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #larg ] !>,
             HOOK [ INDEX #index ] ] ].

norm-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop ],
                          RELS.LIST.FIRST #keyrel ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

norm-hook-lex-item := norm-ltop-lex-item &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX #index,
             LKEYS.KEYREL.ARG0 #index ] ].

no-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST.FIRST #keyrel,
                          HOOK.INDEX #index ],
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].

raise-index-mod-lex-item := norm-ltop-lex-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                   CONT.HOOK.INDEX #index ] ].

single-rel-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

no-hcons-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.HCONS <! !> ].

norm-sem-lex-item := norm-hook-lex-item & single-rel-lex-item.

basic-one-arg := lex-item &
  [ ARG-ST < synsem > ].

basic-two-arg := lex-item &
  [ ARG-ST < synsem, synsem > ].

basic-two-arg-no-hcons := basic-two-arg & no-hcons-lex-item.

transitive-lex-item := basic-two-arg-no-hcons &
   [ ARG-ST < [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind1] ] ],
              [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind2 ] ] ]>,
     SYNSEM [ LKEYS.KEYREL [ ARG1 #ind1,
                             ARG2 #ind2 ],
              LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] ].

basic-verb-lex-super := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD verb ].

basic-verb-lex := basic-verb-lex-super & norm-sem-lex-item &
  [ SYNSEM.LKEYS.KEYREL event-relation ].

basic-noun-lex := norm-sem-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD noun,
             LKEYS.KEYREL noun-relation ]].

noun-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD noun,
                         VAL.SUBJ < > ],
             LKEYS.KEYREL noun-relation ] ].

intransitive-verb-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ ARG-ST < [ LOCAL [ CAT cat-sat,
                       CONT.HOOK.INDEX ref-ind & #ind ] ] >,
    SYNSEM.LKEYS.KEYREL event-relation & [ ARG1 #ind ] ].
    
subj-head-phrase := basic-head-subj-phrase & head-final.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].
