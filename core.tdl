
sign-min := avm &
  [ STEM list ].

basic-sign := sign-min &
  [ KEY-ARG bool ].

sign := basic-sign &
  [ SYNSEM synsem,
    ARGS list,
    INFLECTED inflected ].

phrase-or-lexrule := sign &
  [ SYNSEM canonical-synsem &
       [ LOCAL.CONT.HOOK #hook],
    C-CONT mrs-min & [ HOOK #hook] ].

word-or-lexrule-min := sign-min.

word-or-lexrule := word-or-lexrule-min & sign &
  [ ALTS alts-min,
    ARG-ST list ].

nocoord := sign &
  [ SYNSEM.LOCAL.COORD - ].

alts-min := avm.
alts := alts-min &
  [ PASSIVE bool ].
no-alts := alts-min.

word := word-or-lexrule & nocoord.

lex-item := word-or-lexrule & nocoord.

phrase := phrase-or-lexrule.

non-affix-bearing := word-or-lexrule &
  [ INFLECTED infl-satisfied,
    SYNSEM.LKEYS.KEYREL.WLINK cons ].

rule := sign &
  [ RULE-NAME string ].

tree-node-label := *top* &
  [ NODE sign ].

label := sign &
  [ LABEL-NAME string ].

meta := sign &
  [ META-PREFIX string,
    META-SUFFIX string ].

synsem-min := avm &
  [ OPT bool,
    OPT-CS cog-st,
    LOCAL mod-local,
    NON-LOCAL non-local-min ].

lex-or-phrase-synsem := synsem-min &
  [ LIGHT luk ].

synsem := synsem-min &
  [ L-PERIPH luk,
    R-PERIPH luk ].

expressed-synsem := synsem.

canonical-synsem := expressed-synsem &
  [ MODIFIED xmod ].

lex-synsem := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min,
    LIGHT +,
    LKEYS lexkeys ].

phr-synsem-min := canonical-synsem & lex-or-phrase-synsem &
  [ LOCAL local-min ].

phr-synsem := phr-synsem-min &
  [ LIGHT - ].

non-canonical := synsem &
  [ LOCAL.CONT.HOOK.INDEX event-or-ref-index ].

expressed-non-canonical := non-canonical & expressed-synsem.

gap := expressed-non-canonical &
  [ LOCAL #local,
    NON-LOCAL [ REL 0-dlist,
        QUE 0-dlist,
        SLASH 1-dlist &
            [ LIST < #local > ] ] ].

unexpressed := synsem-min &
  [ NON-LOCAL [ SLASH 0-dlist,
        REL 0-dlist,
        QUE 0-dlist ] ].

unexpressed-reg := unexpressed & non-canonical.


anti-synsem := unexpressed.

mod-local := avm.

local-min := mod-local &
  [ CAT cat-min,
    CONT mrs-min,
    AGR individual,
    COORD bool,
    COORD-REL coordination-relation,
    COORD-STRAT string ].

local := local-min &
  [ CTXT ctxt-min ].

scopal-mod := local.
intersective-mod := local.

non-local-min := avm.

non-local := non-local-min &
  [ SLASH 0-1-dlist,
    QUE 0-1-dlist,
    REL 0-1-dlist ].

non-local-none := non-local &
  [ SLASH 0-dlist & [ LIST < > ],
    QUE 0-dlist,
    REL 0-dlist ].

cat-min := avm.

cat := cat-min &
  [ HEAD head-min,
    VAL valence-min,
    MC luk,
    MKG mkg,
    HC-LIGHT luk,
    POSTHEAD bool ].

cat-sat := cat &
 [ VAL [ SPR olist,
         SPEC olist,
         COMPS olist,
         SUBJ olist ],
  HEAD.MOD olist ].

head-min := avm.

head := head-min &
  [ MOD list,
    PRD bool,
    KEYS keys_min ].


conj := +mo & +do & +co & +po & +ro & +jo & +vo & +no.
num := +mo & +dm & +cm & +pm & +rm & +jm & +vm & +nm.
det := +do & +dm & +cd & +pd & +rd & +jd & +vd & +nd.
comp := +co & +cm & +cd & +pc & +rc & +jc & +vc & +nc.
adp := +po & +pm & +pd & +pc & +rp & +jp & +vp & +np.
adv := +ro & +rm & +rd & +rc & +rp & +jr & +vr & +nr.
adj := +jo & +jm & +jd & +jc & +jp & +jr & +vj & +nj.
verb := +vo & +vm & +vd & +vc & +vp & +vr & +vj & +nv.
noun := +no & +nm & +nd & +nc & +np & +nr & +nj & +nv.

valence-min := avm.

valence := valence-min &
  [ SUBJ list,
    SPR list,
    COMPS list,
    SPEC list,
    --KEYCOMP avm ].

keys_min := avm.
keys := keys_min &
  [ KEY predsort,
    ALTKEY predsort ].

semsort := sort.

mrs-min := avm.

mrs := mrs-min &
  [ HOOK hook,
    RELS diff-list,
    HCONS diff-list,
    ICONS diff-list ].

hook := avm &
  [ GTOP handle,
    LTOP handle,
    INDEX individual,
    XARG individual,
    ICONS-KEY icons,
    CLAUSE-KEY event ].

psoa := mrs &
  [ HOOK.INDEX event ].

nom-obj := mrs &
  [ HOOK.INDEX index ].

lexkeys := avm &
  [ KEYREL relation,
    ALTKEYREL relation,
    --COMPKEY predsort,
    --OCOMPKEY predsort ].

ctxt-min := avm.

ctxt := ctxt-min &
  [ ACTIVATED bool,
    PRESUP diff-list ].


qeq := avm &
  [ HARG handle,
    LARG handle ].


semarg := avm &
  [ INSTLOC string ].

handle := semarg.
individual := semarg &
  [ SORT semsort ].

index := individual &
     [ COG-ST cog-st,
       SPECI bool ].

cog-st := avm.

activ-or-less := cog-st.
uniq-or-more := cog-st.
uniq+fam+act := activ-or-less & uniq-or-more.
fam-or-less := activ-or-less.
fam-or-more := uniq-or-more.
activ+fam := uniq+fam+act & fam-or-more.
uniq+fam := uniq+fam+act & fam-or-less.
uniq-or-less := fam-or-less.
activ-or-more := fam-or-more.
type-id := uniq-or-less.
uniq-id := uniq-or-less & uniq+fam.
familiar := uniq+fam & activ+fam.
activated := activ+fam & activ-or-more.
in-foc := activ-or-more.



event-or-ref-index := individual.

expl-ind := index.

ref-ind := index & event-or-ref-index &
    [ PNG png ].

png := avm.

tense := sort.
aspect := sort.
mood := sort.

tam := avm &
  [ TENSE tense,
    ASPECT aspect,
    MOOD mood ].

iforce := avm.
prop-or-ques := iforce.
prop := prop-or-ques.
ques := prop-or-ques.
comm := iforce.

event := event-or-ref-index &
  [ E tam,
    SF iforce ].

coord-index := event-or-ref-index.
coord-event := coord-index & event.
coord-ref-ind := coord-index & ref-ind.


relation := avm &
  [ LBL handle,
    WLINK list,
    PRED predsort ].

arg0-relation := relation &
  [ ARG0 individual ].

arg1-relation := arg0-relation &
  [ ARG1 semarg ].

arg12-relation := arg1-relation &
  [ ARG2 semarg ].

arg123-relation := arg12-relation &
  [ ARG3 semarg ].

arg1234-relation := arg123-relation &
  [ ARG4 semarg ].

event-relation := arg0-relation &
  [ ARG0 event ].

arg1-ev-relation := arg1-relation & event-relation.
arg12-ev-relation := arg1-ev-relation & arg12-relation.
arg123-ev-relation := arg12-ev-relation & arg123-relation.
arg1234-ev-relation := arg123-ev-relation & arg1234-relation.

noun-relation := arg0-relation &
  [ ARG0 ref-ind ].

noun-arg1-relation := noun-relation & arg1-relation.

named-relation := noun-relation &
  [ PRED named_rel,
    CARG string ].

subord-or-coord-relation := relation &
  [ L-HNDL handle,
    R-HNDL handle ].

coordination-relation := subord-or-coord-relation &
  [ C-ARG coord-index,
    L-INDEX individual,
    R-INDEX individual ].

subord-relation := subord-or-coord-relation.

quant-relation := arg0-relation &
  [ ARG0 ref-ind,
    RSTR handle,
    BODY handle ].

norm_rel := predsort.
named_rel := norm_rel.



icons := avm.

info-str := icons &
  [ IARG1 individual,
    IARG2 individual ].

non-topic := info-str.
contrast-or-focus := info-str.
focus-or-topic := info-str.
contrast-or-topic := info-str.
non-focus := info-str.

focus := non-topic & contrast-or-focus & focus-or-topic.
contrast := focus-or-topic & contrast-or-focus & contrast-or-topic.
topic := non-focus & focus-or-topic & contrast-or-topic.

bg := non-topic & non-focus.

semantic-focus := focus.
contrast-focus := contrast & focus.
contrast-topic := contrast & topic.
aboutness-topic := topic.



luk := sort.

na-or-+ := luk.
na-or-- := luk.
+-or-- := luk.

na := na-or-+ & na-or--.
bool := luk.
+ := bool & na-or-+ & +-or--.
- := bool & na-or-- & +-or--.

xmod := sort &
  [ PERIPH luk ].
notmod-or-rmod := xmod.
notmod-or-lmod := xmod.
notmod := notmod-or-rmod & notmod-or-lmod.

hasmod := xmod.
lmod := hasmod & notmod-or-lmod.
rmod := hasmod & notmod-or-rmod.

sort := *top*.
predsort := sort.
atom := predsort.
no-pred := predsort.
avm := *top*.
list := avm.

cons := list &
  [ FIRST *top*,
    REST list ].

0-1-list := list.
1-list := 0-1-list & cons &
  [ REST null ].
null := 0-1-list.
1-plus-list := cons &
  [ REST cons ].

diff-list := avm &
  [ LIST list,
    LAST list ].

0-1-dlist := diff-list &
  [ LIST 0-1-list ].
0-dlist := 0-1-dlist &
  [ LIST #list,
    LAST #list ].

1-dlist := 0-1-dlist &
  [ LIST 1-list &
     [ REST #rest ],
    LAST #rest ].


dl-append := avm & [APPARG1 [LIST #first,
                             LAST #between],
                    APPARG2 [LIST #between,
                             LAST #last],
                    RESULT  [LIST #first,
                             LAST #last]].

integer := atom.

string := atom.

olist := list.

ocons := olist & cons &
  [ FIRST unexpressed & [ OPT + ],
    REST  olist ].

onull := olist & null.

lex-rule := phrase-or-lexrule & word-or-lexrule &
  [ NEEDS-AFFIX bool,
    SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                   LAST #last ],
            HCONS [ LIST #hfirst,
                LAST #hlast ],
            ICONS [ LIST #ifirst,
                LAST #ilast ] ],
    DTR #dtr & word-or-lexrule &
        [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                         LAST #middle ],
                      HCONS [ LIST #hfirst,
                          LAST #hmiddle ],
                      ICONS [ LIST #ifirst,
                          LAST #imiddle ] ],
          ALTS #alts ],
    C-CONT [ RELS [ LIST #middle,
            LAST #last ],
         HCONS [ LIST #hmiddle,
             LAST #hlast ],
         ICONS [ LIST #imiddle,
             LAST #ilast ] ],
    ALTS #alts,
    ARGS < #dtr > ].

inflected := avm.
infl-satisfied := inflected.

same-local-lex-rule := same-cat-lex-rule &
               same-cont-lex-rule &
               same-ctxt-lex-rule &
               same-agr-lex-rule.

same-non-local-lex-rule := lex-rule &
  [ SYNSEM.NON-LOCAL #nl,
    DTR.SYNSEM.NON-LOCAL #nl ].

same-modified-lex-rule := lex-rule &
  [ SYNSEM.MODIFIED #mod,
    DTR.SYNSEM.MODIFIED #mod ].

same-light-lex-rule := lex-rule &
  [ SYNSEM.LIGHT #light,
    DTR.SYNSEM.LIGHT #light ].

same-ctxt-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CTXT #ctxt,
    DTR.SYNSEM.LOCAL.CTXT #ctxt ].

same-cont-lex-rule := lex-rule &
  [ C-CONT [ HOOK #hook ],
    DTR.SYNSEM.LOCAL.CONT [ HOOK #hook ]].

same-agr-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.AGR #agr,
    DTR.SYNSEM.LOCAL.AGR #agr ].

same-cat-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT #cat,
    DTR.SYNSEM.LOCAL.CAT #cat ].

same-head-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.HEAD #head,
    DTR.SYNSEM.LOCAL.CAT.HEAD #head ].

same-val-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    DTR.SYNSEM.LOCAL.CAT.VAL #val ].

same-subj-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ #subj,
    DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ #subj ].

same-spr-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPR #spr,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPR #spr ].

same-spec-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.SPEC #spec,
    DTR.SYNSEM.LOCAL.CAT.VAL.SPEC #spec ].

same-comps-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].

same-hc-light-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.HC-LIGHT #hcl,
    DTR.SYNSEM.LOCAL.CAT.HC-LIGHT #hcl ].

same-posthead-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.POSTHEAD #ph,
    DTR.SYNSEM.LOCAL.CAT.POSTHEAD #ph ].

same-mc-lex-rule := lex-rule &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    DTR.SYNSEM.LOCAL.CAT.MC #mc ].

no-rels-hcons-lex-rule := lex-rule &
  [ C-CONT [ RELS <! !>, HCONS <! !>  ] ].

no-ccont-lex-rule := no-rels-hcons-lex-rule &
  [ C-CONT.ICONS <! !> ].

non-local-change-only-lex-rule := same-local-lex-rule &
                  same-modified-lex-rule &
                  same-light-lex-rule &
                  no-ccont-lex-rule.

local-change-only-lex-rule := same-non-local-lex-rule &
                  same-modified-lex-rule &
                  same-light-lex-rule &
                  no-ccont-lex-rule.

cont-change-only-lex-rule := same-non-local-lex-rule &
                 same-modified-lex-rule &
                 same-light-lex-rule &
                 same-ctxt-lex-rule &
                 same-cat-lex-rule &
                 same-agr-lex-rule.

ctxt-change-only-lex-rule := local-change-only-lex-rule &
                 same-cont-lex-rule &
                 same-cat-lex-rule &
                 same-agr-lex-rule.

agr-change-only-lex-rule := local-change-only-lex-rule &
                same-cont-lex-rule &
                same-cat-lex-rule &
                same-ctxt-lex-rule.

cat-change-only-lex-rule := local-change-only-lex-rule &
                same-ctxt-lex-rule &
                same-cont-lex-rule &
                same-agr-lex-rule.

head-change-only-lex-rule := cat-change-only-lex-rule &
                 same-val-lex-rule &
                 same-hc-light-lex-rule &
                 same-posthead-lex-rule &
                 same-mc-lex-rule.

mc-change-only-lex-rule := cat-change-only-lex-rule &
               same-val-lex-rule &
               same-hc-light-lex-rule &
               same-posthead-lex-rule &
               same-head-lex-rule.

val-change-only-lex-rule := cat-change-only-lex-rule &
                same-head-lex-rule &
                same-hc-light-lex-rule &
                same-posthead-lex-rule &
                same-mc-lex-rule.

same-gtop-lex-rule := lex-rule &
 [ C-CONT.HOOK.GTOP #gtop,
   DTR.SYNSEM.LOCAL.CONT.HOOK.GTOP #gtop ].

same-ltop-lex-rule := lex-rule &
 [ C-CONT.HOOK.LTOP #ltop,
   DTR.SYNSEM.LOCAL.CONT.HOOK.LTOP #ltop ].

same-index-lex-rule := lex-rule &
 [ C-CONT.HOOK.INDEX #idx,
   DTR.SYNSEM.LOCAL.CONT.HOOK.INDEX #idx ].

same-icons-key-lex-rule := lex-rule &
 [ C-CONT.HOOK.ICONS-KEY #icons,
   DTR.SYNSEM.LOCAL.CONT.HOOK.ICONS-KEY #icons ].

same-clause-key-lex-rule := lex-rule &
 [ C-CONT.HOOK.CLAUSE-KEY #clause,
   DTR.SYNSEM.LOCAL.CONT.HOOK.CLAUSE-KEY #clause ].



xarg-change-only-ccont-lex-rule :=  same-gtop-lex-rule &
                                    same-ltop-lex-rule &
                                    same-index-lex-rule &
                                    same-icons-key-lex-rule &
                                    same-clause-key-lex-rule.

cat-change-with-ccont-lex-rule := same-modified-lex-rule &
                                  same-light-lex-rule &
                                  same-ctxt-lex-rule &
                                  same-agr-lex-rule.

val-change-with-ccont-lex-rule := cat-change-with-ccont-lex-rule &
                                  same-head-lex-rule &
                                  same-hc-light-lex-rule &
                                  same-posthead-lex-rule &
                                  same-mc-lex-rule.

comps-change-only-lex-rule := same-subj-lex-rule &
                              same-spr-lex-rule &
                              same-spec-lex-rule.

subj-change-only-lex-rule := same-comps-lex-rule &
                             same-spr-lex-rule &
                             same-spec-lex-rule.

subj-and-comps-change-only-lex-rule := same-spr-lex-rule &
                                       same-spec-lex-rule.

local-change-with-ccont-lex-rule := same-non-local-lex-rule &
                                    same-modified-lex-rule &
                                    same-light-lex-rule.

cat-mod-change-with-ccont-lex-rule := local-change-with-ccont-lex-rule &
                                      same-ctxt-lex-rule &
                                      same-cont-lex-rule &
                                      same-agr-lex-rule.

head-change-with-ccont-lex-rule := cat-mod-change-with-ccont-lex-rule &
                                   same-val-lex-rule &
                                   same-hc-light-lex-rule &
                                   same-posthead-lex-rule &
                                   same-mc-lex-rule.

add-only-rule := same-local-lex-rule &
                 same-modified-lex-rule &
                 same-light-lex-rule &
                 same-non-local-lex-rule.

add-only-no-ccont-rule := add-only-rule &
                          no-ccont-lex-rule.

add-only-no-rels-hcons-rule := add-only-rule &
                               no-rels-hcons-lex-rule.

inflecting-lex-rule := lex-rule &
  [ NEEDS-AFFIX + ].

constant-lex-rule := lex-rule &
  [ STEM #stem,
    DTR [ STEM #stem ]].

infl-lex-rule := inflecting-lex-rule & nocoord.
const-lex-rule := constant-lex-rule & nocoord.

infl-non-local-change-only-lex-rule := non-local-change-only-lex-rule &
                                       infl-lex-rule.

infl-local-change-only-lex-rule := local-change-only-lex-rule &
                                   infl-lex-rule.

infl-cont-change-only-lex-rule := cont-change-only-lex-rule &
                                  infl-lex-rule.

infl-ctxt-change-only-lex-rule := ctxt-change-only-lex-rule &
                                  infl-lex-rule.

infl-agr-change-only-lex-rule := agr-change-only-lex-rule &
                                 infl-lex-rule.

infl-cat-change-only-lex-rule := cat-change-only-lex-rule &
                                 infl-lex-rule.

infl-head-change-only-lex-rule := head-change-only-lex-rule &
                                  infl-lex-rule.

infl-val-change-only-lex-rule := val-change-only-lex-rule &
                                 infl-lex-rule.

infl-add-only-lex-rule := add-only-rule & infl-lex-rule.

infl-add-only-no-rels-hcons-lex-rule := add-only-rule & infl-lex-rule &
  [ C-CONT [ RELS <! !>, HCONS <! !> ] ].

infl-add-only-no-ccont-lex-rule := add-only-no-ccont-rule &
                                   infl-lex-rule.

const-non-local-change-only-lex-rule := non-local-change-only-lex-rule &
                                        const-lex-rule.

const-local-change-only-lex-rule := local-change-only-lex-rule &
                                    const-lex-rule.

const-cont-change-only-lex-rule := cont-change-only-lex-rule &
                                   const-lex-rule.

const-ctxt-change-only-lex-rule := ctxt-change-only-lex-rule &
                                   const-lex-rule.

const-agr-change-only-lex-rule := agr-change-only-lex-rule &
                                  const-lex-rule.

const-cat-change-only-lex-rule := cat-change-only-lex-rule &
                                  const-lex-rule.

const-head-change-only-lex-rule := head-change-only-lex-rule &
                                   const-lex-rule.

const-val-change-only-lex-rule := val-change-only-lex-rule &
                                  const-lex-rule.

const-add-only-lex-rule := add-only-rule & const-lex-rule.

const-add-only-no-rels-hcons-lex-rule := add-only-rule & const-lex-rule &
  [ C-CONT [ RELS <! !>, HCONS <! !> ] ].

const-add-only-no-ccont-lex-rule := add-only-no-ccont-rule & const-lex-rule.


headed-phrase := phrase &
  [ SYNSEM.LOCAL [ CAT.HEAD head & #head,
                   AGR #agr,
                   COORD -,
                   COORD-REL #crel ],
    C-CONT.HOOK.ICONS-KEY #icons,
    HEAD-DTR.SYNSEM.LOCAL local &
         [ CAT.HEAD #head,
           CONT.HOOK.ICONS-KEY #icons,
           AGR #agr,
           COORD -,
           COORD-REL #crel ] ].

non-headed-phrase := phrase.

phrasal := phrase &
  [ SYNSEM phr-synsem ].

head-nexus-rel-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.REL #rel,
    HEAD-DTR.SYNSEM.NON-LOCAL.REL #rel ].

head-nexus-que-phrase := headed-phrase &
  [ SYNSEM.NON-LOCAL.QUE #que,
    HEAD-DTR.SYNSEM.NON-LOCAL.QUE #que ].

head-nexus-phrase := head-nexus-rel-phrase & head-nexus-que-phrase.


head-valence-phrase := head-nexus-phrase &
  [ SYNSEM.NON-LOCAL.SLASH #slash,
    HEAD-DTR.SYNSEM.NON-LOCAL.SLASH #slash ].

basic-unary-phrase := phrase &
  [ STEM #stem,
    SYNSEM [ L-PERIPH #lperiph,
         R-PERIPH #rperiph,
         LOCAL [ CAT.MKG #mkg,
             CONT [ RELS [ LIST #first,
                   LAST #last ],
                HCONS [ LIST #scfirst,
                    LAST #sclast ],
                ICONS [ LIST #icfirst,
                    LAST #iclast ] ] ] ],
    C-CONT [ RELS [ LIST #middle,
            LAST #last ],
         HCONS [ LIST #scmiddle,
             LAST #sclast ],
         ICONS [ LIST #icmiddle,
             LAST #iclast ] ],
    ARGS < sign & [ STEM #stem,
            SYNSEM [ L-PERIPH #lperiph,
                 R-PERIPH #rperiph,
                 LOCAL local &
                  [ CAT.MKG #mkg,
                CONT [ RELS [ LIST #first,
                          LAST #middle ],
                       HCONS [ LIST #scfirst,
                           LAST #scmiddle ],
                       ICONS [ LIST #icfirst,
                           LAST #icmiddle ] ] ] ] ] > ].

unary-phrase := basic-unary-phrase &
  [ INFLECTED infl-satisfied,
    ARGS < [ INFLECTED infl-satisfied ] > ].

basic-binary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
            HCONS [ LIST #scfirst,
                    LAST #sclast ],
            ICONS [ LIST #icfirst,
                    LAST #iclast ] ],
    C-CONT [ RELS [ LIST #middle2,
                    LAST #last ],
         HCONS [ LIST #scmiddle2,
                 LAST #sclast ],
         ICONS [ LIST #icmiddle2,
                 LAST #iclast ] ],
    ARGS < sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #first,
                                 LAST #middle1 ],
                      HCONS [ LIST #scfirst,
                              LAST #scmiddle1 ],
                      ICONS [ LIST #icfirst,
                              LAST #icmiddle1 ] ] ] ],
       sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle1,
                                 LAST #middle2 ],
                      HCONS [ LIST #scmiddle1,
                              LAST #scmiddle2 ],
                      ICONS [ LIST #icmiddle1,
                              LAST #icmiddle2 ] ] ] ] > ].

binary-phrase := basic-binary-phrase &
  [ INFLECTED infl-satisfied,
    ARGS < [ INFLECTED infl-satisfied ],
           [ INFLECTED infl-satisfied ] > ].

basic-binary-headed-phrase := headed-phrase & basic-binary-phrase &
  [ NON-HEAD-DTR sign & [ SYNSEM.LOCAL.COORD - ] ].

binary-headed-phrase := basic-binary-headed-phrase & binary-phrase.

basic-ternary-phrase := phrase &
  [ SYNSEM.LOCAL.CONT [ RELS [ LIST #first,
                               LAST #last ],
            HCONS [ LIST #scfirst,
                    LAST #sclast ],
            ICONS [ LIST #icfirst,
                    LAST #iclast ] ],
    C-CONT [ RELS [ LIST #middle3,
                    LAST #last ],
         HCONS [ LIST #scmiddle3,
                 LAST #sclast ],
         ICONS [ LIST #icmiddle3,
                 LAST #iclast ] ],
    ARGS <
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #first,
                                 LAST #middle1 ],
                      HCONS [ LIST #scfirst,
                              LAST #scmiddle1 ],
                      ICONS [ LIST #icfirst,
                              LAST #icmiddle1 ] ] ] ],
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle1,
                                 LAST #middle2 ],
                      HCONS [ LIST #scmiddle1,
                              LAST #scmiddle2 ],
                      ICONS [ LIST #icmiddle1,
                              LAST #icmiddle2 ] ] ] ],
        sign & [ SYNSEM.LOCAL local &
                 [ CONT [ RELS [ LIST #middle2,
                                 LAST #middle3 ],
                      HCONS [ LIST #scmiddle2,
                              LAST #scmiddle3 ],
                      ICONS [ LIST #icmiddle2,
                              LAST #icmiddle3 ] ] ] ]> ].

ternary-phrase := basic-ternary-phrase &
  [ INFLECTED infl-satisfied,
    ARGS < [ INFLECTED infl-satisfied,
             SYNSEM.LOCAL.COORD - ],
           [ INFLECTED infl-satisfied,
             SYNSEM.LOCAL.COORD - ],
           [ INFLECTED infl-satisfied,
             SYNSEM.LOCAL.COORD - ] > ].


ternary-headed-phrase := headed-phrase & ternary-phrase.

ternary-head-middle-phrase := ternary-headed-phrase &
  [ SYNSEM.LOCAL.CAT.VAL #val,
    HEAD-DTR #head &
        [ SYNSEM.LOCAL.CAT.VAL #val ],
    ARGS.REST.FIRST #head ].


binary-rule-left-to-right := basic-binary-phrase &
  [ ARGS < [ KEY-ARG + ] , [ KEY-ARG bool ] > ].

binary-rule-right-to-left := basic-binary-phrase &
  [ ARGS < [ KEY-ARG bool ], [ KEY-ARG + ] > ].

head-only := unary-phrase & headed-phrase &
  [ HEAD-DTR #head,
    ARGS < #head > ].

head-initial := binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #head, #non-head > ].

basic-head-final := basic-binary-headed-phrase &
  [ HEAD-DTR #head,
    NON-HEAD-DTR #non-head,
    ARGS < #non-head, #head > ].

head-final := basic-head-final & binary-headed-phrase.

head-compositional := headed-phrase &
  [ C-CONT.HOOK #hook,
    HEAD-DTR.SYNSEM.LOCAL.CONT.HOOK #hook ].


clause := phrasal &
  [ SYNSEM.NON-LOCAL.QUE 0-dlist ].


basic-non-rel-clause := clause & head-compositional &
  [ SYNSEM.NON-LOCAL.REL 0-dlist,
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #index,
                    ICONS-KEY.IARG1 #index,
                    CLAUSE-KEY #index ],
              NON-LOCAL [ QUE 0-dlist,
                  REL 0-dlist ] ],
    C-CONT [ RELS <! !>,
         HCONS <! !> ] ].

declarative-clause := basic-non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF prop-or-ques ].

imperative-clause := basic-non-rel-clause &
  [ SYNSEM.LOCAL.CONT.HOOK.INDEX.SF comm ].


basic-head-subj-phrase := head-valence-phrase & head-compositional &
              basic-binary-headed-phrase &
  [ SYNSEM phr-synsem &
           [ LOCAL.CAT [ HC-LIGHT -,
                         VAL [ SUBJ < >,
                               COMPS #comps,
                               SPR #spr ] ] ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #synsem >,
                                    COMPS #comps,
                                    SPR #spr ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
           [ LOCAL [ CAT [ VAL [ SUBJ olist,
                                 COMPS olist,
                                 SPR olist ] ] ],
             NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                         REL 0-dlist,
                         QUE 0-dlist ] ],
    C-CONT [ RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

decl-head-subj-phrase := basic-head-subj-phrase & declarative-clause.

basic-bare-np-phrase := head-only & head-valence-phrase &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           SUBJ < >,
                           COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  VAL [ SPR < unexpressed &
                                              [ LOCAL.CAT.HEAD +nd,
                                                OPT + ] >,
                                        SUBJ < >,
                                        COMPS < > ] ],
                            CONT.HOOK [ INDEX #index,
                                        LTOP #larg ] ],
    C-CONT [ RELS <! quant-relation &
                     [ ARG0 #index,
                       RSTR #harg ] !>,
             HCONS <! qeq &
                      [ HARG #harg,
                        LARG #larg ] !>,
             ICONS <! !>,
             HOOK [ INDEX #index ] ] ].


norm-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ HOOK [ LTOP #ltop ],
                          RELS.LIST.FIRST #keyrel ],
             LKEYS.KEYREL #keyrel & [ LBL #ltop ] ] ].

norm-hook-lex-item := norm-ltop-lex-item &
  [ SYNSEM [ LOCAL.CONT.HOOK.INDEX #index,
             LKEYS.KEYREL.ARG0 #index ] ].

no-ltop-lex-item := lex-item &
  [ SYNSEM [ LOCAL.CONT [ RELS.LIST.FIRST #keyrel,
                          HOOK.INDEX #index ],
             LKEYS.KEYREL #keyrel & [ ARG0 #index ] ] ].


raise-index-mod-lex-item := norm-ltop-lex-item &
  [ SYNSEM.LOCAL [ CAT.HEAD.MOD < [ LOCAL.CONT.HOOK.INDEX #index ] >,
                   CONT.HOOK.INDEX #index ] ].

single-rel-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.RELS <! relation !> ].

no-hcons-lex-item := lex-item &
  [ SYNSEM.LOCAL.CONT.HCONS <! !> ].

no-rels-hcons-icons-lex-item := no-hcons-lex-item &
  [ SYNSEM.LOCAL.CONT [ RELS <! !>, ICONS <! !> ] ].

basic-icons-lex-item := lex-item & [ SYNSEM.LOCAL.CONT.ICONS <! !> ].

norm-sem-lex-item := norm-hook-lex-item & single-rel-lex-item.

hcons-lex-item := norm-hook-lex-item & single-rel-lex-item.

basic-one-arg := lex-item &
  [ ARG-ST < [ NON-LOCAL [ SLASH #slash,
                           REL #rel,
                           QUE #que ] ] >,
    SYNSEM.NON-LOCAL [ SLASH #slash,
                       REL #rel,
                       QUE #que ] ].


basic-two-arg := lex-item &
  [ ARG-ST < [ NON-LOCAL [ SLASH [ LIST #smiddle,
                                   LAST #slast ],
                           REL [ LIST #rmiddle,
                                 LAST #rlast ],
                           QUE [ LIST #qmiddle,
                                 LAST #qlast ] ] ],
              [ NON-LOCAL [ SLASH [ LIST #sfirst,
                                    LAST #smiddle ],
                            REL [ LIST #rfirst,
                                  LAST #rmiddle ],
                            QUE [ LIST #qfirst,
                                  LAST #qmiddle ] ] ] >,
    SYNSEM.NON-LOCAL [ SLASH [ LIST #sfirst,
                               LAST #slast ],
                       REL [ LIST #rfirst,
                             LAST #rlast ],
                       QUE [ LIST #qfirst,
                             LAST #qlast ] ] ].

basic-two-arg-no-hcons := basic-two-arg & no-hcons-lex-item.

transitive-lex-item := basic-two-arg-no-hcons & basic-icons-lex-item &
   [ ARG-ST < [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind1,
                                    ICONS-KEY.IARG1 #clause ] ] ],
              [ LOCAL [ CAT cat-sat,
                        CONT.HOOK [ INDEX ref-ind & #ind2,
                                    ICONS-KEY.IARG1 #clause ] ] ]>,
     SYNSEM [ LKEYS.KEYREL [ ARG1 #ind1,
                             ARG2 #ind2 ],
              LOCAL.CONT.HOOK.CLAUSE-KEY #clause ] ].

basic-verb-lex-super := lex-item &
  [ SYNSEM.LOCAL.CAT.HEAD verb ].

basic-verb-lex := basic-verb-lex-super & norm-sem-lex-item &
  [ SYNSEM.LKEYS.KEYREL event-relation ].

basic-noun-lex := norm-sem-lex-item & basic-icons-lex-item &
  [ SYNSEM [ LOCAL.CAT.HEAD noun,
             LKEYS.KEYREL noun-relation ]].

mkg := avm & [ FC luk, TP luk ].
fc := mkg & [ FC + ].
non-tp := mkg & [ TP - ].
tp := mkg & [ TP + ].
non-fc := mkg & [ FC - ].
fc-only := fc & non-tp.
fc-+-tp := tp & fc.
unmkg := non-tp & non-fc.
tp-only := tp & non-fc.


noun-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ SYNSEM [ LOCAL.CAT [ HEAD noun,
                         VAL.SUBJ < > ],
             LKEYS.KEYREL noun-relation ] ].

intransitive-verb-lex := norm-sem-lex-item & basic-one-arg & no-hcons-lex-item &
  [ ARG-ST < [ LOCAL [ CAT cat-sat,
                       CONT.HOOK.INDEX ref-ind & #ind ] ] >,
    SYNSEM.LKEYS.KEYREL event-relation & [ ARG1 #ind ] ].
    
subj-head-phrase := basic-head-subj-phrase & head-final.

bare-np-phrase := basic-bare-np-phrase &
  [ C-CONT.RELS <! [ PRED "exist_q_rel" ] !> ].
